/// <reference types="deno" />
/// <reference lib="deno.window" />
/// <reference lib="dom" />
/// <reference lib="dom.iterable" />
/// <reference lib="dom.asynciterable" />

import { serve } from 'https://deno.land/std@0.168.0/http/server.ts';
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.38.4';
import OpenAI from 'https://esm.sh/openai@4.86.1';
import { HubspotClient, HubspotRecord } from '../_shared/hubspotClient.ts';
import { Logger } from '../_shared/logger.ts';
import { decrypt, encrypt } from '../_shared/encryption.ts';
import { DocumentPackager } from '../_shared/documentPackager.ts';
import { PineconeClient } from '../_shared/pineconeClient.ts';

declare const Deno: {
  env: {
    get(key: string): string | undefined;
  };
};

const logger = new Logger('hubspot-auto-training-v2');

// Helper functions
async function sleep(ms: number) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

function chunkArray<T>(array: T[], size: number): T[][] {
  const chunks: T[][] = [];
  for (let i = 0; i < array.length; i += size) {
    chunks.push(array.slice(i, i + size));
  }
  return chunks;
}

function calculateConversionDays(properties: any): number {
  const createDate = new Date(properties.createdate);
  const closeDate = properties.closedate ? new Date(properties.closedate) : null;
  
  if (!closeDate) return 0;
  
  return Math.ceil((closeDate.getTime() - createDate.getTime()) / (1000 * 60 * 60 * 24));
}

/**
 * Handles API calls with automatic token refresh
 */
async function handleApiCall<T>(
  hubspotClient: HubspotClient,
  portalId: string | number,
  refreshToken: string,
  apiCall: () => Promise<T>
): Promise<T> {
  try {
    logger.info(`Making API call for portal ${portalId}`);
    return await apiCall();
  } catch (error) {
    logger.error(`API call error:`, { message: error.message, status: error.status });

    // Check if the error is due to token expiration
    if (error.status === 401) {
      logger.info(`Token expired for portal ${portalId}, refreshing token...`);
      
      try {
        // Refresh the token
        const supabase = createClient(
          Deno.env.get('SUPABASE_URL')!,
          Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!
        );

        const refreshResult = await hubspotClient.refreshToken(
          refreshToken,
          Deno.env.get('HUBSPOT_CLIENT_ID')!,
          Deno.env.get('HUBSPOT_CLIENT_SECRET')!
        );

        if (!refreshResult || !refreshResult.access_token) {
          throw new Error('Failed to refresh token: Invalid response');
        }

        // Update the client with the new token
        hubspotClient.setToken(refreshResult.access_token);

        // Encrypt the new tokens and update in the database
        const encryptedAccessToken = await encrypt(
          refreshResult.access_token,
          Deno.env.get('ENCRYPTION_KEY')!
        );

        const encryptedRefreshToken = await encrypt(
          refreshResult.refresh_token,
          Deno.env.get('ENCRYPTION_KEY')!
        );

        const { error: updateError } = await supabase
          .from('hubspot_accounts')
          .update({
            access_token: encryptedAccessToken,
            refresh_token: encryptedRefreshToken,
            expires_at: new Date(Date.now() + 1800 * 1000).toISOString(), // Default to 30 minutes
            updated_at: new Date().toISOString()
          })
          .eq('portal_id', portalId);

        if (updateError) {
          throw new Error(`Failed to update tokens in database: ${updateError.message}`);
        }

        logger.info(`Successfully refreshed and updated token for portal ${portalId}`);

        // Retry the API call with the new token
        logger.info(`Retrying API call with new token for portal ${portalId}`);
        return await apiCall();
      } catch (refreshError) {
        logger.error(`Token refresh failed for portal ${portalId}:`, refreshError);
        throw new Error(`Token refresh failed: ${refreshError.message}`);
      }
    }

    // For other errors, propagate them
    throw error;
  }
}

/**
 * Fetches deals for training from HubSpot
 */
async function getDealsForTraining(
  hubspotClient: HubspotClient, 
  type: 'ideal' | 'nonideal',
  portalId: string,
  refreshToken: string
): Promise<any[]> {
  try {
    // Define time range - last 90 days
    const ninety_days_ago = new Date();
    ninety_days_ago.setDate(ninety_days_ago.getDate() - 90);
    
    const allDeals: any[] = [];
    let hasMore = true;
    let after: string | null = null;

    // Pagination loop to fetch all deals
    while (hasMore) {
      await sleep(2000); // Rate limiting

      const searchCriteria = {
        filterGroups: [{
          filters: [
            {
              propertyName: 'createdate',
              operator: 'GTE',
              value: Math.floor(ninety_days_ago.getTime() / 1000).toString()
            },
            {
              propertyName: 'dealstage',
              operator: 'EQ',
              value: type === 'ideal' ? 'closedwon' : 'closedlost'
            }
          ]
        }],
        sorts: [
          {
            propertyName: 'createdate',
            direction: 'DESCENDING'
          }
        ],
        properties: [
          'dealname',
          'amount',
          'closedate',
          'createdate',
          'dealstage',
          'pipeline',
          'hs_lastmodifieddate',
          'hs_date_entered_closedwon',
          'hs_date_entered_closedlost'
        ],
        limit: 25, // Fetch 25 at a time
        associations: ['contacts', 'companies'],
        ...(after ? { after } : {})
      };

      logger.info(`Searching for ${type} deals with criteria:`, JSON.stringify(searchCriteria, null, 2));
      
      // Make API call with token refresh handling
      const deals = await handleApiCall(
        hubspotClient,
        portalId,
        refreshToken,
        () => hubspotClient.searchRecords('deals', searchCriteria)
      );
      
      logger.info(`Found ${deals.total || 0} total ${type} deals, fetched ${deals.results?.length || 0} in this batch`);
      
      if (deals.results?.length) {
        // Sample logging
        const sampleDeal = deals.results[0];
        logger.info('Sample deal associations:', {
          dealId: sampleDeal.id,
          hasAssociations: !!sampleDeal.associations,
          contactsCount: sampleDeal.associations?.contacts?.results?.length || 0,
          companiesCount: sampleDeal.associations?.companies?.results?.length || 0
        });
        
        allDeals.push(...deals.results);
      }

      // Check if more pages are available
      hasMore = deals.paging?.next?.after !== undefined;
      after = deals.paging?.next?.after || null;

      if (hasMore) {
        logger.info(`More deals available, continuing with after=${after}`);
        await sleep(5000); // Additional rate limiting between pages
      }
    }

    logger.info(`Total ${type} deals collected: ${allDeals.length}`);
    
    // Process deals in batches to get full details
    const fullDeals: any[] = [];
    const dealBatches = chunkArray(allDeals, 5);

    for (const batch of dealBatches) {
      logger.info(`Processing batch of ${batch.length} deals for full details`);
      
      for (const deal of batch) {
        try {
          // Defensive checks
          if (!deal || !deal.id) {
            logger.error('Invalid deal object', { deal });
            continue;
          }

          await sleep(3000); // Rate limiting
          logger.info(`Fetching full details for deal ${deal.id}`);

          try {
            const fullDeal = await handleApiCall(
              hubspotClient,
              portalId,
              refreshToken,
              () => hubspotClient.getRecord('deals', deal.id, [
                'dealname',
                'amount',
                'closedate',
                'createdate',
                'dealstage',
                'pipeline',
                'hs_lastmodifieddate',
                'hs_date_entered_closedwon',
                'hs_date_entered_closedlost',
                'hs_deal_stage_probability',
                'hs_pipeline_stage',
                'hs_time_in_pipeline',
                'hs_time_in_dealstage',
                'hs_deal_stage_changes'
              ])
            );

            if (fullDeal) {
              // Preserve the associations from the search results
              fullDeal.associations = deal.associations;
              fullDeals.push(fullDeal);
              logger.info(`Successfully added full details for deal ${deal.id}`);
              await sleep(1000);
            }
          } catch (error) {
            logger.error(`Error fetching full details for deal ${deal.id}:`, error);
            await sleep(5000);
          }
        } catch (error) {
          logger.error(`Error processing deal ${deal?.id || 'unknown'}:`, error);
          await sleep(5000);
        }
      }

      logger.info(`Completed batch processing. Retrieved ${fullDeals.length} deals with full details.`);
      await sleep(8000); // Rate limiting between batches
    }

    return fullDeals;
  } catch (error) {
    logger.error(`Error fetching ${type} deals:`, error);
    throw error;
  }
}

/**
 * Fetches contacts and companies associated with a deal
 */
async function getAssociatedRecords(hubspotClient: HubspotClient, deal: any) {
  const contacts: HubspotRecord[] = [];
  const companies: HubspotRecord[] = [];

  try {
    // Check for associated contacts
    if (deal.associations?.contacts?.results?.length > 0) {
      logger.info(`Fetching ${deal.associations.contacts.results.length} contacts for deal ${deal.id}`);
      
      for (const contact of deal.associations.contacts.results) {
        try {
          const contactData = await hubspotClient.getContact(contact.id);
          if (contactData) {
            contacts.push(contactData);
            logger.info(`Retrieved contact ${contact.id}`);
          }
          await sleep(1000); // Rate limiting
        } catch (error) {
          logger.error(`Error fetching contact ${contact.id}:`, error);
        }
      }
    }

    // Check for associated companies
    if (deal.associations?.companies?.results?.length > 0) {
      logger.info(`Fetching ${deal.associations.companies.results.length} companies for deal ${deal.id}`);
      
      for (const company of deal.associations.companies.results) {
        try {
          const companyData = await hubspotClient.getCompany(company.id);
          if (companyData) {
            companies.push(companyData);
            logger.info(`Retrieved company ${company.id}`);
          }
          await sleep(1000); // Rate limiting
        } catch (error) {
          logger.error(`Error fetching company ${company.id}:`, error);
        }
      }
    }

    logger.info(`Retrieved ${contacts.length} contacts and ${companies.length} companies for deal ${deal.id}`);
    return { contacts, companies };
  } catch (error) {
    logger.error(`Error fetching associated records for deal ${deal.id}:`, error);
    // Return whatever we managed to retrieve
    return { contacts, companies };
  }
}

/**
 * Processes a batch of deals and uploads them to Pinecone
 */
async function processDeals(
  deals: any[],
  classification: 'ideal' | 'nonideal',
  hubspotClient: HubspotClient,
  documentPackager: DocumentPackager,
  openai: OpenAI,
  pineconeClient: PineconeClient,
  portalId: string
) {
  logger.info(`Processing ${deals.length} ${classification} deals`);
  
  // Process deals in smaller batches
  const dealBatches = chunkArray(deals, 5);
  logger.info(`Split into ${dealBatches.length} batches of up to 5 deals each`);
  
  for (const batch of dealBatches) {
    logger.info(`Processing batch of ${batch.length} deals`);
    
    for (const deal of batch) {
      try {
        logger.info(`Processing deal: ${deal.id} - ${deal.properties?.dealname}`);
        
        // Get associated records
        const { contacts, companies } = await getAssociatedRecords(hubspotClient, deal);
        
        // Create documents for the deal and associated records
        logger.info(`Creating documents for deal ${deal.id} and ${contacts.length} contacts, ${companies.length} companies`);
        
        // Calculate deal metadata
        const dealMetadata = {
          deal_id: deal.id,
          deal_value: parseFloat(deal.properties?.amount) || 0,
          conversion_days: calculateConversionDays(deal.properties),
          pipeline: deal.properties?.pipeline || 'unknown',
          dealstage: deal.properties?.dealstage || 'unknown',
          days_in_pipeline: parseInt(deal.properties?.hs_time_in_pipeline) || 0
        };
        
        // Create documents for deal
        const dealDoc = await documentPackager.packageDocument(deal, 'deal', portalId);
        dealDoc.metadata = {
          ...dealDoc.metadata,
          ...dealMetadata,
          classification,
          record_type: 'deal'
        };
        
        // Create documents for contacts
        const contactDocs = await Promise.all(
          contacts.map(async contact => {
            const doc = await documentPackager.packageDocument(contact, 'contact', portalId);
            return {
              ...doc,
              metadata: {
                ...doc.metadata,
                ...dealMetadata, // Include deal metadata
                classification,
                record_type: 'contact'
              }
            };
          })
        );
        
        // Create documents for companies
        const companyDocs = await Promise.all(
          companies.map(async company => {
            const doc = await documentPackager.packageDocument(company, 'company', portalId);
            return {
              ...doc,
              metadata: {
                ...doc.metadata,
                ...dealMetadata, // Include deal metadata
                classification,
                record_type: 'company'
              }
            };
          })
        );
        
        // Combine all documents
        const allDocs = [dealDoc, ...contactDocs, ...companyDocs];
        logger.info(`Created ${allDocs.length} total documents for deal ${deal.id}`);
        
        // Get embeddings from OpenAI
        const embeddingResponse = await openai.embeddings.create({
          model: 'text-embedding-3-large',
          input: allDocs.map(doc => doc.content)
        });
        
        logger.info(`Received ${embeddingResponse.data.length} embeddings from OpenAI`);
        
        // Upsert to Pinecone
        const namespace = `hubspot-${portalId}`;
        try {
          logger.info(`Upserting vectors to Pinecone namespace ${namespace}`);
          
          await pineconeClient.upsertVectorsWithDealMetadata(
            namespace,
            allDocs,
            embeddingResponse.data,
            dealMetadata
          );
          
          logger.info(`Successfully upserted vectors for deal ${deal.id}`);
        } catch (error) {
          logger.error(`Error upserting vectors for deal ${deal.id}:`, error);
        }
        
        await sleep(3000); // Rate limiting between deals
      } catch (error) {
        logger.error(`Error processing deal ${deal?.id}:`, error);
        await sleep(5000);
      }
    }
    
    logger.info(`Completed batch of ${batch.length} deals`);
    await sleep(10000); // Rate limiting between batches
  }
  
  logger.info(`Completed processing ${deals.length} ${classification} deals`);
}

/**
 * Main handler for the edge function
 */
serve(async (req) => {
  try {
    logger.info('Starting hubspot-auto-training-v2');
    
    // Handle CORS preflight
    if (req.method === "OPTIONS") {
      return new Response(null, {
        headers: {
          "Access-Control-Allow-Origin": "*",
          "Access-Control-Allow-Methods": "POST",
          "Access-Control-Allow-Headers": "Content-Type, Authorization",
        },
      });
    }

    // Validate request method
    if (req.method !== "POST") {
      throw new Error(`Method ${req.method} not allowed. Only POST requests are accepted.`);
    }

    // Initialize Supabase client
    const supabase = createClient(
      Deno.env.get('SUPABASE_URL')!,
      Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!
    );

    // Fetch all HubSpot accounts
    const { data: accounts, error: accountsError } = await supabase
      .from('hubspot_accounts')
      .select('*')
      .eq('status', 'active');

    if (accountsError) {
      throw new Error(`Failed to fetch accounts: ${accountsError.message}`);
    }

    if (!accounts || accounts.length === 0) {
      throw new Error('No active HubSpot accounts found');
    }

    logger.info(`Found ${accounts.length} active HubSpot accounts to process`);

    // Track results
    const results = {
      total: accounts.length,
      processed: 0,
      successful: 0,
      failed: 0,
      portals: [] as any[]
    };

    // Process each account
    for (const account of accounts) {
      const portalId = account.portal_id;
      logger.info(`\n=== Processing portal ${portalId} ===`);

      try {
        // Initialize clients and services
        const decryptedToken = await decrypt(account.access_token, Deno.env.get('ENCRYPTION_KEY')!);
        const decryptedRefreshToken = await decrypt(account.refresh_token, Deno.env.get('ENCRYPTION_KEY')!);
        
        if (!decryptedToken || !decryptedRefreshToken) {
          throw new Error('Invalid HubSpot tokens');
        }
        
        const hubspotClient = new HubspotClient(decryptedToken);
        const openai = new OpenAI({ apiKey: Deno.env.get('OPENAI_API_KEY')! });
        const pineconeClient = new PineconeClient();
        await pineconeClient.initialize(Deno.env.get('PINECONE_API_KEY')!, Deno.env.get('PINECONE_INDEX')!);
        const documentPackager = new DocumentPackager(hubspotClient);
        
        // Validate token
        logger.info(`Validating token for portal ${portalId}`);
        await handleApiCall(hubspotClient, portalId, decryptedRefreshToken, () => 
          hubspotClient.searchRecords('contacts', { limit: 1 })
        );
        
        // Clear the Pinecone namespace to start fresh
        try {
          const namespace = `hubspot-${portalId}`;
          logger.info(`Clearing Pinecone namespace ${namespace}`);
          await pineconeClient.deleteNamespace(namespace);
          logger.info(`Successfully cleared namespace ${namespace}`);
        } catch (error) {
          // Ignore 404 errors (namespace doesn't exist)
          if (!error.message?.includes('404')) {
            logger.warn(`Error clearing Pinecone namespace:`, error);
          }
        }
        
        // Track portal results
        const portalResult = {
          portalId,
          ideal: { total: 0, processed: 0 },
          nonideal: { total: 0, processed: 0 }
        };
        
        // Process ideal deals
        logger.info(`Fetching ideal deals for portal ${portalId}`);
        const idealDeals = await getDealsForTraining(hubspotClient, 'ideal', portalId, decryptedRefreshToken);
        portalResult.ideal.total = idealDeals.length;
        
        if (idealDeals.length > 0) {
          logger.info(`Processing ${idealDeals.length} ideal deals`);
          await processDeals(
            idealDeals,
            'ideal',
            hubspotClient,
            documentPackager,
            openai,
            pineconeClient,
            portalId
          );
          portalResult.ideal.processed = idealDeals.length;
        }
        
        // Process non-ideal deals
        logger.info(`Fetching non-ideal deals for portal ${portalId}`);
        const nonIdealDeals = await getDealsForTraining(hubspotClient, 'nonideal', portalId, decryptedRefreshToken);
        portalResult.nonideal.total = nonIdealDeals.length;
        
        if (nonIdealDeals.length > 0) {
          logger.info(`Processing ${nonIdealDeals.length} non-ideal deals`);
          await processDeals(
            nonIdealDeals,
            'nonideal',
            hubspotClient,
            documentPackager,
            openai,
            pineconeClient,
            portalId
          );
          portalResult.nonideal.processed = nonIdealDeals.length;
        }
        
        // Update database with metrics
        await supabase
          .from('hubspot_accounts')
          .update({
            last_training_date: new Date().toISOString(),
            current_ideal_deals: portalResult.ideal.processed,
            current_less_ideal_deals: portalResult.nonideal.processed
          })
          .eq('portal_id', portalId);
        
        // Track success
        results.portals.push(portalResult);
        results.successful++;
        logger.info(`Successfully processed portal ${portalId}`);
      } catch (error) {
        // Track failure
        results.failed++;
        logger.error(`Failed to process portal ${portalId}:`, error);
        results.portals.push({
          portalId,
          error: error.message
        });
      }
      
      results.processed++;
    }

    // Return the response
    return new Response(
      JSON.stringify({
        success: true,
        message: `Processed ${results.processed} HubSpot accounts`,
        results
      }),
      {
        headers: { "Content-Type": "application/json" },
        status: 200,
      }
    );
  } catch (error) {
    logger.error('Error in hubspot-auto-training-v2:', error);
    return new Response(
      JSON.stringify({
        success: false,
        error: error.message
      }),
      {
        headers: { "Content-Type": "application/json" },
        status: 500,
      }
    );
  }
}); 